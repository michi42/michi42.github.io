
<!doctype html>
<html><head><title>Tank-War</title>
<style>
body {
	font-family: sans-serif;
}
</style>

<meta charset="utf-8" />
</head>
<body>

<div id="tankwar">
</div>

<script>

var tankwar = (function() {
	
	var Settings = {
		landColor: [0,127,0],
		skyColor: [56,0,160]
	};
	
	var FightGUI = function(container) {
		container.style.width = '640px';
		container.style.height = '480px';
	
		var gui = document.createElement('img');
		gui.src = 'data/fightgui.png';
		gui.style.position = 'absolute';
		gui.style.top = 0; gui.style.left = 0;
		gui.style.zIndex = 10;
		container.appendChild(gui);
		
		var gameCanvas = document.createElement('canvas');
		var overlayCanvas = document.createElement('canvas');
		gameCanvas.width = overlayCanvas.width = 610;
		gameCanvas.height = overlayCanvas.height = 375;
		gameCanvas.zIndex = 1; overlayCanvas.zIndex = 2;
		gameCanvas.style.position = overlayCanvas.style.position = 'absolute';
		gameCanvas.style.top = overlayCanvas.style.top = '65px';
		gameCanvas.style.left = overlayCanvas.style.left = '15px';		
		
		container.appendChild(gameCanvas); container.appendChild(overlayCanvas);
		
		container.style.position = 'relative';
		
		// expose canvas contexts for drawing
		this.gameCtx = gameCanvas.getContext('2d');
		this.overlayCtx = overlayCanvas.getContext('2d');
		
		var powerDisplay = document.createElement('div');
		powerDisplay.style.position = 'absolute';
		powerDisplay.style.top = '10px'; powerDisplay.style.left = '72px';
		powerDisplay.style.width = '60px'; powerDisplay.style.height = '18px';
		powerDisplay.style.textAlign = 'center'; powerDisplay.style.zIndex = 20;
		container.appendChild(powerDisplay);

		var angleDisplay = document.createElement('div');
		angleDisplay.style.position = 'absolute';
		angleDisplay.style.top = '32px'; angleDisplay.style.left = '72px';
		angleDisplay.style.width = '60px'; angleDisplay.style.height = '18px';
		angleDisplay.style.textAlign = 'center'; angleDisplay.style.zIndex = 20;
		container.appendChild(angleDisplay);

		this.display = function(tank) {
			powerDisplay.innerHTML = tank.power;
			angleDisplay.innerHTML = tank.angle;
		}
		
	}
	
	var Sprite = function(imageSrc,frameHeight,frameDuration,offsetX,offsetY,onloadCallback) {
		this.initialized = false;
		this.frameHeight = frameHeight;
		this.frameDuration = frameDuration;
		this.offsetX = offsetX;
		this.offsetY = offsetY

		this.image = new Image();
		this.image.sprite = this;
		this.image.src = imageSrc;
		this.image.onload = function() {
			this.sprite.numFrames = Math.round(this.height / frameHeight);
			this.sprite.frameWidth = this.width;
			console.log(this.sprite);
			this.sprite.initialized = true;
			if(onloadCallback) onloadCallback();
		}
		this.draw = function(ctx, ticks, dx, dy, scale) {
			if(!this.initialized) return;
			var frame = Math.round(ticks / this.frameDuration);
			var lastFrame = false;
			if(frame >= this.numFrames) {
				lastFrame = true;
				frame = this.numFrames-1;
			}
			ctx.drawImage(this.image,
				0,frame*this.frameHeight,this.frameWidth,this.frameHeight,
				dx-this.offsetX*scale,ctx.canvas.clientHeight-(dy+this.offsetY*scale),
				Math.round(this.frameWidth*scale),Math.round(this.frameHeight*scale)
			);
			return lastFrame;
		}
		
		return this;
	}
	
	var Tank = function(color, game) {
		this.game = game;
		this.color = color;
		
		this.gfxBuffer = document.createElement('canvas');
		this.gfxBuffer.width = 20;
		this.gfxBuffer.height = 18;
		this.gfxCtx = this.gfxBuffer.getContext('2d');
		

		this.angle = 135;
		this.power = 500;
		this.hitpoints = 100;

		this.x = 200;
		this.y = 200;
		
		var tempAngle = this.angle;
		var tempPower = this.power;
		
		this.changeAngle = function(angle) {
			tempAngle = (tempAngle + 180 + angle) % 180;
			this.angle = Math.round(tempAngle);
			this.update();
		}
		this.changePower = function(power) {
			tempPower += power;
			if(tempPower < 0) tempPower = 0;
			if(tempPower > 1000) tempPower = 1000;
			this.power = 5*Math.round(tempPower/5);
			this.update();
		}
		this.fire = function() {
			game.fireWeapon(this.weapon, this);
		}
		
		this.update = function() {
			this.gfxCtx.clearRect(0,0,20,20);
			if(this.angle >= 90)
				game.sprites.tankL.draw(this.gfxCtx,0,2,-6,1);
			else
				game.sprites.tankR.draw(this.gfxCtx,0,2,-6,1);

			var pixels = this.gfxCtx.getImageData(0,0,20,18);
			for(var i=0;i<pixels.data.length;i+=4) {
				if(pixels.data[i]==255&&pixels.data[i+1]==255&&pixels.data[i+2]==255) {
					pixels.data[i] = this.color.r;
					pixels.data[i+1] = this.color.g;
					pixels.data[i+2] = this.color.b;
				}
			}
			this.gfxCtx.putImageData(pixels,0,0);
			this.gfxCtx.strokeStyle='rgb('+this.color.r+','+this.color.g+','+this.color.b+')';
			this.gfxCtx.beginPath();
			this.gfxCtx.lineWidth=1.5;
			this.gfxCtx.moveTo(10,8);
			this.gfxCtx.lineTo(10+Math.cos(this.angle*Math.PI/180)*8,8-Math.sin(this.angle*Math.PI/180)*8);
			this.gfxCtx.stroke();
		}
		
		this.fall = function(ticks) {
			if(this.y > game.terrain.heights[this.x]) {
				this.y -= ticks/5;
				if(this.y <= game.terrain.heights[this.x]+1) {
					this.y = game.terrain.heights[this.x]+2;
					return false;
				}
				return true;
			}
			return false;
		}
		
		this.draw = function(ctx) {
			ctx.drawImage(this.gfxBuffer,Math.round(this.x-9),Math.round(ctx.canvas.clientHeight-(this.y+16)));
		}

		this.update();
	}
	
	var Bullet = function(x,y,vx,vy,game) {
		this.game = game;
		this.x = x; this.y = y;
		this.vx = vx; this.vy = vy;
		this.tick = function(collisonCtx, ticks) {
			this.x += (ticks/300)*this.vx; 
			this.y += (ticks/300)*this.vy;
			this.vy -= (ticks/300)*9.81;
			var pixels = collisonCtx.getImageData(this.x-1,collisonCtx.canvas.clientHeight-(this.y+1),3,3);
			for(var i=0; i<pixels.data.length; i+=4) {
				if(pixels.data[i+3]==0) continue;
				if(pixels.data[i]!=Settings.skyColor[0] || pixels.data[i+1]!=Settings.skyColor[1] || pixels.data[i+2]!=Settings.skyColor[2]) {
					return this.collide();
				}
			}
			return true;
		}
		
		this.draw = function(ctx) {
			ctx.fillStyle='rgb(200,200,0)';
			ctx.fillRect(Math.round(this.x-1),Math.round(ctx.canvas.clientHeight-(this.y+1)),3,3);
		}
		
		this.collide = function() { return false; } // instantanously at collision (return true to keep the bullet alive)
		this.explode = function() { return false; } // after all motion was handled (return true if exploded)
		this.action = function() { return false; }  // on player action (space bar) (return true if handled)
	}
	var Bomb = function(x,y,vx,vy,game,size) {
		this.game = game;
		this.size = size;
		this.x = x; this.y = y;
		this.vx = vx; this.vy = vy;
		
		this.explode = function() {
			this.game.explosionManager.add(this.game.sprites.explosion,this.x,this.y,this.size);
			return true;
		}
	}
	Bomb.prototype = new Bullet();

	var Controller = function() {
		this.inputState = {up: false, down: false, left: false, right: false, fast: false, trigger: false};
		
		this.controlTank = function(tank, game, ticks) {
			if(this.inputState.left) {
				tank.changeAngle((ticks/1000)*(this.inputState.fast?100:20));
				return true;
			}
			if(this.inputState.right) {
				tank.changeAngle(-(ticks/1000)*(this.inputState.fast?100:20));
				return true;
			}
			if(this.inputState.up) {
				tank.changePower((ticks/1000)*(this.inputState.fast?100:20)*5);
				return true;
			}
			if(this.inputState.down) {
				tank.changePower(-(ticks/1000)*(this.inputState.fast?100:20)*5);
				return true;
			}
			if(this.inputState.trigger) {
				tank.fire();
			}
			
		}
	}
	
	var KeyboardController = function() {
		var controller = this;
		document.documentElement.addEventListener('keydown',function(ev) {
			if(ev.repeat) return;
			if(ev.keyCode == 37) controller.inputState.left = true;
			if(ev.keyCode == 38) controller.inputState.up = true;
			if(ev.keyCode == 39) controller.inputState.right = true;
			if(ev.keyCode == 40) controller.inputState.down = true;

			if(ev.keyCode == 32) controller.inputState.trigger = true;

			if(ev.keyCode == 16) controller.inputState.fast = true;			
		}, false);
		document.documentElement.addEventListener('keyup',function(ev) {
			if(ev.keyCode == 37) controller.inputState.left = false;
			if(ev.keyCode == 38) controller.inputState.up = false;
			if(ev.keyCode == 39) controller.inputState.right = false;
			if(ev.keyCode == 40) controller.inputState.down = false;

			if(ev.keyCode == 32) controller.inputState.trigger = false;

			if(ev.keyCode == 16) controller.inputState.fast = false;			
		}, false);
	}
	KeyboardController.prototype = new Controller();
	
	return {

		terrain : {
			heights: [],
			isIndestructible: false,
			
			pseudoFractalLandgen: function(width, maxHeight, roughness) {
				var nextPow2=Math.ceil(Math.log(width)/Math.LN2);
				var nextPow2val=1<<nextPow2;
				var terrain=[];
				terrain[0] = 50+(maxHeight-100)*Math.random();
				terrain[nextPow2val] = 50+(maxHeight-100)*Math.random();
				for(var i=1;i<=nextPow2;i++) {
					var step=1<<(nextPow2-i);
					for(var j=0;j<nextPow2val;j+=step) {
						if(j in terrain) continue;
						do {
							terrain[j] = (terrain[j-step]+terrain[j+step])/2 + ((Math.random()-0.5)*maxHeight)*Math.pow(roughness,i-1);
						} while(terrain[j]<0||terrain[j]>maxHeight);
					}
				}
				return terrain.splice(0,width);
			},
			
			generate: function(width, maxHeight, options) {
				this.heights = this.pseudoFractalLandgen(width, maxHeight, options['roughness']);
			},
			
			updateFromImage: function(ctx) {
				if(this.isIndestructible) return;
				var W=ctx.canvas.clientWidth, H=ctx.canvas.clientHeight;
				var pixels = ctx.getImageData(0,0,W,H);
				for(var i=0;i<W;i++) this.heights[i]=0;
				for(var i=0;i<pixels.data.length;i+=4) {
					if(pixels.data[i+0]==Settings.landColor[0] && pixels.data[i+1]==Settings.landColor[1] && pixels.data[i+2]==Settings.landColor[2])
						this.heights[(i/4)%W]++;
				}				
			},
			
			drawToImage: function(ctx) {
				var W=ctx.canvas.clientWidth, H=ctx.canvas.clientHeight;
				var pixels = ctx.getImageData(0,0,W,H);
				for(var i=0;i<pixels.data.length;i+=4) {
					if(this.heights[(i/4)%W] >= (H-(i/4)/W)) {
						pixels.data[i+0]=Settings.landColor[0];
						pixels.data[i+1]=Settings.landColor[1];
						pixels.data[i+2]=Settings.landColor[2];
						pixels.data[i+3]=255;
					} else {
						pixels.data[i+0]=Settings.skyColor[0];
						pixels.data[i+1]=Settings.skyColor[1];
						pixels.data[i+2]=Settings.skyColor[2];
						pixels.data[i+3]=255;
					}
				}
				ctx.putImageData(pixels,0,0);				
			}
		},
		
		explosionManager: {
			animations: [],
			finished: true,
			add: function(sprite,x,y,scale) {
				this.finished = false;
				this.animations.push({sprite: sprite, x: x, y: y, scale: scale, ticks: 0});
			},
			tick: function(ctx,ticks) {
				if(this.finished)
					return true;
				this.finished = true;
				for(var i=0; i<this.animations.length; i++) {
					var anim = this.animations[i];
					if(anim.sprite.draw(ctx,anim.ticks,anim.x,anim.y,anim.scale)) {
						this.animations.splice(i,1);
						i--;
					} else {
						this.finished = false;
					}
					anim.ticks += ticks;
				}
				return this.finished;
			},
		},
		
		tankManager: {
			tanks: [],
			falling: false,
			
			add: function(tank) {
				this.tanks.push(tank);
			},
			
			fall: function(ticks) {
				this.falling = false;
				for(var i=0; i<this.tanks.length; i++) {
					if(this.tanks[i].fall(ticks))
						this.falling = true;
				}
				if(this.falling) return true;
				return false;
			},
			
			drawAll: function(ctx) {
				for(var i=0; i<this.tanks.length; i++)
					this.tanks[i].draw(ctx);
			}
		},
		
		projectileManager: {
			projectiles: [],
			flying: false,
			
			add: function(projectile) {
				this.projectiles.push(projectile);
			},
			
			tick: function(collisonCtx, overlayCtx, ticks) {
				this.flying = false;
				overlayCtx.clearRect(0,0,overlayCtx.canvas.width,overlayCtx.canvas.height)
				for(var i=0; i<this.projectiles.length; i++) {
					if(this.projectiles[i].tick(collisonCtx, ticks))
						this.flying = true;
					this.projectiles[i].draw(overlayCtx);
				}
				
				// finished?
				if(this.flying) return false;
				for(var i=0; i<this.projectiles.length; i++) {
					this.projectiles[i].explode();
					this.projectiles.splice(i,1); i--;
				}				
				overlayCtx.clearRect(0,0,overlayCtx.canvas.width,overlayCtx.canvas.height)				
				return true;
			},
		},

		state: "UNINITIALIZED",
		
		sprites: {},
		initialize: function(container,onloadCallback) {
			var game = this;
			
			var spriteLoaded = function() {
				var done = true;
				for(var sprite in game.sprites)
					done &= game.sprites[sprite].initialized;
				game.state = "PREGAME";
				if(done && onloadCallback) onloadCallback();
			}
			this.sprites.explosion = new Sprite('data/explosion.png', 225, 10, 112, 112, spriteLoaded);
			this.sprites.atom = new Sprite('data/atom.png', 290, 10, 160, 290, spriteLoaded);
			
			this.sprites.tankL = new Sprite('data/tank-l.png',13, 1, 0, 0, spriteLoaded);
			this.sprites.tankR = new Sprite('data/tank-r.png',13, 1, 0, 0, spriteLoaded);
			
			this.gui = new FightGUI(container);
		},
		

		start: function() {
			var ctx = this.gui.gameCtx; var overlayCtx = this.gui.overlayCtx;
		
			this.terrain.generate(ctx.canvas.clientWidth,ctx.canvas.clientHeight-100,{'roughness':0.55});
			this.terrain.drawToImage(ctx);
			this.state = "MOVING";

			var testTank = new Tank({r:255,g:127,b:0},this);
			testTank.y = this.terrain.heights[testTank.x];
			this.tankManager.add(testTank);
			this.tankManager.drawAll(ctx);
			this.gui.display(testTank);

			// game loop
			this.controller = new KeyboardController();
			var game = this;
			var lastTicks = -1;
			function doFrame(ticks) {
				if(lastTicks==-1) lastTicks = ticks;
				var dTicks = ticks-lastTicks;
				switch(game.state) {
					case "MOVING":
						if(game.controller.controlTank(testTank, game, dTicks)) {
							game.terrain.drawToImage(ctx);
							game.tankManager.drawAll(ctx);
							game.gui.display(testTank);
						}
					break;
					
					case "SHOOTING":
						if(game.projectileManager.tick(ctx,overlayCtx,dTicks))
							game.state = "EXPLODING";
							
					break;
					case "EXPLODING":
						if(game.explosionManager.tick(ctx,dTicks)) {
							// all animations complete
							game.terrain.updateFromImage(ctx);
							game.terrain.drawToImage(ctx);
							game.tankManager.drawAll(ctx);
							game.state = "FALLING";
						}
					break;
					
					case "FALLING":
						if(!game.tankManager.fall(dTicks)) {
							game.state = "MOVING";
						}
						game.terrain.drawToImage(ctx);
						game.tankManager.drawAll(ctx);
					break;
				}
				lastTicks = ticks;
				requestAnimationFrame(doFrame);
			}
			requestAnimationFrame(doFrame);
		},
		
		fireWeapon: function(weapon, tank) {
			this.state = "SHOOTING";
			var muzzleX = tank.x + Math.cos(tank.angle*Math.PI/180)*11;
			var muzzleY = tank.y + 8 + Math.sin(tank.angle*Math.PI/180)*11;
			var vx =  Math.cos(tank.angle*Math.PI/180)*tank.power/10;
			var vy =  Math.sin(tank.angle*Math.PI/180)*tank.power/10;
			
			this.projectileManager.add(new Bomb(muzzleX,muzzleY,vx,vy,this,0.5));
		}

	}
})();

tankwar.initialize(document.getElementById('tankwar'), function() {
	tankwar.start();
});

</script>
</body></html>