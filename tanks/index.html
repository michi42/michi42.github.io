
<!doctype html>
<html><head><title>Tank-War</title>
<style>
body {
	font-family: sans-serif;
}
</style>

<meta charset="utf-8" />
</head>
<body>

<div id="tankwar">
</div>

<script>

var tankwar = (function() {
	
	var Settings = {
		landColor: [0,127,0],
		skyColor: [56,0,160]
	};
	
	var FightGUI = function(container) {
		container.style.width = '640px';
		container.style.height = '480px';
	
		var gui = document.createElement('img');
		gui.src = 'data/fightgui.png';
		gui.style.position = 'absolute';
		gui.style.top = 0; gui.style.left = 0;
		gui.style.zIndex = 0;
		container.appendChild(gui);
		
		var gameCanvas = document.createElement('canvas');
		var overlayCanvas = document.createElement('canvas');
		gameCanvas.width = overlayCanvas.width = 610;
		gameCanvas.height = overlayCanvas.height = 375;
		gameCanvas.zIndex = 1; overlayCanvas.zIndex = 2;
		gameCanvas.style.position = overlayCanvas.style.position = 'absolute';
		gameCanvas.style.top = overlayCanvas.style.top = '65px';
		gameCanvas.style.left = overlayCanvas.style.left = '15px';		
		
		container.appendChild(gameCanvas); container.appendChild(overlayCanvas);
		
		container.style.position = 'relative';
		
		// expose canvas contexts for drawing
		this.gameCtx = gameCanvas.getContext('2d');
		this.overlayCtx = overlayCanvas.getContext('2d');
		
		var powerDisplay = document.createElement('div');
		powerDisplay.style.position = 'absolute';
		powerDisplay.style.top = '9px'; powerDisplay.style.left = '72px';
		powerDisplay.style.width = '60px'; powerDisplay.style.height = '18px';
		powerDisplay.style.textAlign = 'center'; powerDisplay.style.zIndex = 20;
		container.appendChild(powerDisplay);

		var angleDisplay = document.createElement('div');
		angleDisplay.style.position = 'absolute';
		angleDisplay.style.top = '32px'; angleDisplay.style.left = '72px';
		angleDisplay.style.width = '60px'; angleDisplay.style.height = '18px';
		angleDisplay.style.textAlign = 'center'; angleDisplay.style.zIndex = 20;
		container.appendChild(angleDisplay);

		var nameDisplay = document.createElement('div');
		nameDisplay.style.position = 'absolute';
		nameDisplay.style.top = '8px'; nameDisplay.style.left = '480px';
		nameDisplay.style.width = '153px'; nameDisplay.style.height = '18px';
		nameDisplay.style.textAlign = 'center'; nameDisplay.style.zIndex = 20;
		container.appendChild(nameDisplay);

		
		var hitpointDisplay = document.createElement('div');
		hitpointDisplay.style.position = 'absolute';
		hitpointDisplay.style.top = '31px'; hitpointDisplay.style.left = '534px';
		hitpointDisplay.style.width = '100px'; hitpointDisplay.style.height = '18px';
		hitpointDisplay.style.textAlign = 'center'; hitpointDisplay.style.zIndex = 20;
		hitpointDisplay.style.background = 'linear-gradient(to right, red, lime 100px)';
		container.appendChild(hitpointDisplay);

		var weaponSelection = document.createElement('select');
		weaponSelection.style.position = 'absolute';
		weaponSelection.id = 'tankWeaponSelection';
		weaponSelection.style.top = '457px'; weaponSelection.style.left = '71px';
		weaponSelection.style.width = '210px'; weaponSelection.style.height = '18px';
		weaponSelection.style.textAlign = 'center'; weaponSelection.style.zIndex = 20;
		weaponSelection.style.borderRadius = '0'; weaponSelection.style.border = '0'; 
		weaponSelection.style.background = 'transparent'; weaponSelection.style.outline = '0';
		weaponSelection.onchange = function(){this.blur()};
		container.appendChild(weaponSelection);
		

		this.display = function(tank) {
			powerDisplay.innerHTML = tank.power;
			angleDisplay.innerHTML = tank.angle;
			nameDisplay.innerHTML = tank.name;
			hitpointDisplay.style.width = Math.round(tank.hitpoints)*100/tank.maxHitpoints+'px';
			weaponSelection.innerHTML = '';
			var weapons = tank.armory.listWeapons();
			for(var i=0; i<weapons.length; i++) {
				var option = document.createElement('option');
				option.innerHTML = weapons[i].name;
				option.value = weapons[i].id;
				option.selected = weapons[i].selected;
				weaponSelection.appendChild(option);
			}
		}
		
	}
	
	var WallManager = function(game) {
		// return false to kill the bullet (explode)
		// return true to keep it
		this.collide = function(projectile, collision) { return false; }
	}
	
	var OpenWallManager = function(game) {
		this.collide = function(projectile, collision) {
			// top collision
			if(collision.top)
				return true;

			if(collision.left || collision.right)
				projectile.kill(); // kill (no explosion)

			return false;
		}
	}
	OpenWallManager.prototype = new WallManager();	
	
	var BouncyWallManager = function(game) {
		this.collide = function(projectile, collision) {
			if(collision.top)
				projectile.vy = -Math.abs(projectile.vy)*0.8;
			if(collision.left)
				projectile.vx = Math.abs(projectile.vx)*0.8;
			if(collision.right)
				projectile.vx = -Math.abs(projectile.vx)*0.8;
			if(collision.bottom)
				projectile.vy = Math.abs(projectile.vy)*0.8;
				
			if(projectile.vx*projectile.vx+projectile.vy*projectile.vy < 100)
				return false;

			return true;
		}		
	}
	BouncyWallManager.prototype = new WallManager();	
	
	var Sprite = function(imageSrc,frameHeight,frameDuration,offsetX,offsetY,onloadCallback) {
		this.initialized = false;
		this.frameHeight = frameHeight;
		this.frameDuration = frameDuration;
		this.offsetX = offsetX;
		this.offsetY = offsetY

		this.image = new Image();
		this.image.sprite = this;
		this.image.src = imageSrc;
		this.image.onload = function() {
			this.sprite.numFrames = Math.round(this.height / frameHeight);
			this.sprite.frameWidth = this.width;
			this.sprite.initialized = true;
			if(onloadCallback) onloadCallback();
		}
		this.draw = function(ctx, ticks, dx, dy, scale) {
			if(!this.initialized) return;
			var frame = Math.round(ticks / this.frameDuration);
			var lastFrame = false;
			if(frame >= this.numFrames) {
				lastFrame = true;
				frame = this.numFrames-1;
			}
			ctx.drawImage(this.image,
				0,frame*this.frameHeight,this.frameWidth,this.frameHeight,
				dx-this.offsetX*scale,ctx.canvas.clientHeight-(dy+this.offsetY*scale),
				Math.round(this.frameWidth*scale),Math.round(this.frameHeight*scale)
			);
			return lastFrame;
		}
		
		return this;
	}
	
	var Tank = function(name, maxHitpoints, color, game) {
		this.initialize = function(name, maxHitpoints, color, game) {
			this.name = name;
			this.game = game;
			this.color = color;
			this.maxHitpoints = maxHitpoints
		
			this.gfxBuffer = document.createElement('canvas');
			this.gfxBuffer.width = 20;
			this.gfxBuffer.height = 18;
			this.gfxCtx = this.gfxBuffer.getContext('2d');
		

			this.angle = 0;
			this.power = 500;
			this.hitpoints = this.maxHitpoints;
			this.armory = new Armory(this,game);

			this.x = 0;
			this.y = 0;
		}
		this.initialize.apply(this,arguments);
		
		var tempAngle = this.angle;
		var tempPower = this.power;
		
		this.changeAngle = function(angle) {
			tempAngle = (tempAngle + 180 + angle) % 180;
			this.angle = Math.round(tempAngle);
			this.update();
		}
		this.changePower = function(power) {
			tempPower += power;
			if(tempPower < 0) tempPower = 0;
			if(tempPower > 1000) tempPower = 1000;
			this.power = 5*Math.round(tempPower/5);
			this.update();
		}
		this.fire = function() {
			var weapon = this.armory.useWeapon();
			if(!weapon) return false;
			game.fireWeapon(weapon, this);
		}
		this.damage = function(dmg) {
			if(this.hitpoints <= 0) return;
			this.hitpoints -= dmg.thermal;
			this.hitpoints -= dmg.physical;
			this.update();
			if(this.hitpoints <= 0)
				this.hitpoints = 0;
		}
		this.getMuzzle = function() {
			return {
				x: this.x + Math.cos(this.angle*Math.PI/180)*11,
				y: this.y + 8 + Math.sin(this.angle*Math.PI/180)*11,
				vx: Math.cos(this.angle*Math.PI/180)*(this.power+1)/10,
				vy: Math.sin(this.angle*Math.PI/180)*(this.power+1)/10
			}
		}
		
		this.update = function() {
			this.gfxCtx.clearRect(0,0,20,20);
			if(this.angle >= 90)
				game.sprites.tankL.draw(this.gfxCtx,0,2,-6,1);
			else
				game.sprites.tankR.draw(this.gfxCtx,0,2,-6,1);

			var curColor = {r: Math.round(this.color.r*(this.hitpoints/this.maxHitpoints)),
			                g: Math.round(this.color.g*(this.hitpoints/this.maxHitpoints)),
			                b: Math.round(this.color.b*(this.hitpoints/this.maxHitpoints))};
			var pixels = this.gfxCtx.getImageData(0,0,20,18);
			for(var i=0;i<pixels.data.length;i+=4) {
				if(pixels.data[i]==255&&pixels.data[i+1]==255&&pixels.data[i+2]==255) {
					pixels.data[i] = curColor.r;
					pixels.data[i+1] = curColor.g;
					pixels.data[i+2] = curColor.b;
				}
			}
			this.gfxCtx.putImageData(pixels,0,0);
			this.gfxCtx.strokeStyle='rgb('+curColor.r+','+curColor.g+','+curColor.b+')';
			this.gfxCtx.beginPath();
			this.gfxCtx.lineWidth=1.5;
			this.gfxCtx.moveTo(10,8);
			this.gfxCtx.lineTo(10+Math.cos(this.angle*Math.PI/180)*8,8-Math.sin(this.angle*Math.PI/180)*8);
			this.gfxCtx.stroke();
		}
		
		this.fall = function(ticks) {
			if(this.y > game.terrain.heights[this.x]) {
				this.y -= ticks/5;
				if(this.y <= game.terrain.heights[this.x]+1) {
					this.y = game.terrain.heights[this.x]+2;
					return false;
				}
				return true;
			}
			return false;
		}
		
		this.draw = function(ctx) {
			if(this.hitpoints < 0) return;
			ctx.drawImage(this.gfxBuffer,Math.round(this.x-9),Math.round(ctx.canvas.clientHeight-(this.y+16)));
		}

		this.update();
	}
	
	var Projectile = function(x,y,vx,vy,game) {
		this.initialize = function(x,y,vx,vy,game) {
			this.game = game;
			this.x = x; this.y = y;
			this.vx = vx; this.vy = vy;
		}
		this.initialize.apply(this, arguments);
	
		this.kill = function() {
			this.x = NaN; this.y = NaN;
			this.explode = function() {};
		}

		this.tick = function(collisionCtx, ticks) {
			if(isNaN(this.x) || isNaN(this.y))
				return false;
			var ax = 0, ay = -9.81, dt = (ticks/300);
			this.x += this.vx*dt + ax*dt*dt/2; 
			this.y += this.vy*dt + ay*dt*dt/2;
			this.vx += ax*dt;
			this.vy += ay*dt;
			
			// check for pixel / terrain / tank collision
			var pixels = collisionCtx.getImageData(this.x-1,collisionCtx.canvas.height-(this.y+1),3,3);
			for(var i=0; i<pixels.data.length; i+=4) {
				if(pixels.data[i+3]==0) continue;
				if(pixels.data[i]!=Settings.skyColor[0] || pixels.data[i+1]!=Settings.skyColor[1] || pixels.data[i+2]!=Settings.skyColor[2]) {
					return this.terrainCollide();
				}
			}

			// check for wall collision
			var wallCollision = {top: false, bottom: false, left: false, right: false};
			if(this.x <= 0) wallCollision.left = true;
			if(this.y <= 0) wallCollision.bottom = true;
			if(this.x >= collisionCtx.canvas.width) wallCollision.right = true;
			if(this.y >= collisionCtx.canvas.height) wallCollision.top = true;
			if(wallCollision.left||wallCollision.right||wallCollision.top||wallCollision.bottom)
				return this.wallCollide(wallCollision);

			return true;
		}
		
		this.draw = function(ctx) {
			ctx.fillStyle='rgb(200,200,0)';
			ctx.fillRect(Math.round(this.x-1),Math.round(ctx.canvas.clientHeight-(this.y+1)),3,3);
		}
		
		this.terrainCollide = function() { return false; } // instantanously at collision (return true to keep the bullet alive)
		this.wallCollide = function(collision) { return this.game.wallManager.collide(this,collision); }
		this.explode = function() { return false; } // after all motion was handled (return true if exploded)
		this.action = function() { return false; }  // on player action (space bar) (return true if handled)
	}
	var ProjBomb = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.options = options;
		this.explode = function() {
			this.game.explosionManager.add(this.game.sprites.explosion,this.x,this.y,this.options.size);

			var bomb = this;
			this.game.tankManager.damage(function(tx, ty) {
				var dx = bomb.x-tx, dy = bomb.y-ty;
				var dist = Math.sqrt(dx*dx+dy*dy);
				var realsize = 130*bomb.options.size;
				var dmg = bomb.options.damage*(realsize-dist)/realsize;
				if(dmg<0) dmg = 0;
				return {thermal: dmg*0.2, physical: dmg*0.8}
			});

			return true;
		}
	}
	ProjBomb.prototype = new Projectile();

	var ProjFrog = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.options = options;
		this.forksLeft = this.options.forks;
		this.terrainCollide = function() {
			if(this.forksLeft == 0) return false;
			this.forksLeft--;
			this.vy = Math.abs(this.vy)+8;
			this.y = this.game.terrain.heights[Math.round(this.x)]+3;
			this.game.projectileManager.add(new ProjBomb(this.x,this.y,0,0,this.game,options));
			return true;
		}

	}
	ProjFrog.prototype = new ProjBomb();
	
	ProjDigger = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.explode = function() {
			this.game.explosionManager.add({
				totalTicks: 0,
				tunnels: null,
				draw: function(ctx,ticks,hitX,hitY) {
					if(this.tunnels == null) {
						this.tunnels = [];
						for(var i=0; i<options.numTunnels; i++) {
							this.tunnels.push({
								x: hitX,
								y: hitY,
								angle: Math.random()*360
							});
						}
					}
					var dt = ticks - this.totalTicks;
					for(var i=0; i<this.tunnels.length; i++) {
						ctx.beginPath();
						ctx.strokeStyle = 'rgb('+Settings.skyColor.join(',')+')';
						ctx.moveTo(this.tunnels[i].x,ctx.canvas.height-this.tunnels[i].y);
						this.tunnels[i].x += Math.cos(this.tunnels[i].angle*Math.PI/180)*dt/5;
						this.tunnels[i].y += Math.sin(this.tunnels[i].angle*Math.PI/180)*dt/5;
						this.tunnels[i].angle += (Math.random()-0.5)*20*dt/10;
						ctx.lineTo(this.tunnels[i].x,ctx.canvas.height-this.tunnels[i].y);
						ctx.lineWidth = options.tunnelWidth;
						ctx.stroke();
					}
					this.totalTicks = ticks;
					return (this.totalTicks > 3000);
					
				}
			},this.x,this.y);

			return true;
		}		
	}
	ProjDigger.prototype = new Projectile();
	
	ProjDirt = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.explode = function() {
			this.game.explosionManager.add({
				draw: function(ctx,ticks,hitX,hitY) {
					var angle = 135-ticks/10;
					ctx.beginPath();
					ctx.fillStyle = 'rgb('+Settings.landColor.join(',')+')';
					ctx.moveTo(hitX,ctx.canvas.height-hitY);
					ctx.arc(hitX,ctx.canvas.height-hitY,options.size,-135*Math.PI/180,-angle*Math.PI/180);
					ctx.fill();
					return (angle < 45);
					
				}
			},this.x,this.y);

			return true;
		}		
	}
	ProjDirt.prototype = new Projectile();
	
	ProjLaser = function(x,y,vx,vy,game) {
		var dx = vx / Math.sqrt(vx*vx+vy*vy);
		var dy = vy / Math.sqrt(vx*vx+vy*vy);

		this.initialize.apply(this, arguments);
		this.tick = function() {return false} // 'explode' = trigger instantly
		this.explode = function() {
			this.game.explosionManager.add({
				draw: function(ctx,ticks,ownX,ownY) {
					var sx = ownX+dx*(ticks/7), sy = ownY+dy*(ticks/7);
					var mx = dx*100, my = dy*100;
					var grad = ctx.createLinearGradient(sx-mx, ctx.canvas.height-(sy-my), sx, ctx.canvas.height-sy);
					if((ticks/7)<100) {
						mx = (ticks/7)*dx;
						my = (ticks/7)*dy;
					}
					grad.addColorStop(1, 'yellow');
					grad.addColorStop(0.5, 'red');
					grad.addColorStop(0.1, 'rgb('+Settings.skyColor.join(',')+')');
					ctx.beginPath();
					ctx.lineWidth = 2.5+0.0005*ticks;
					ctx.strokeStyle = grad
					ctx.moveTo(sx-mx,ctx.canvas.height-(sy-my));
					ctx.lineTo(sx,ctx.canvas.height-sy);
					ctx.stroke();
					game.tankManager.damage(function(tx,ty) {						
						return {
							physical:0,
							thermal: Math.sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy))<8 ? 200 : 0
						}
					});
					return (ticks > 5000 || sx < 0 || sy < 0 || sx > ctx.canvas.width || sy > ctx.canvas.height);
					
				}
			},this.x,this.y);

			return true;
		}		
	}
	ProjLaser.prototype = new Projectile();
	
	ProjNapalm = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.explode = function() {
			this.game.explosionManager.add({
				napalm: null,
				totalTicks: 0,
				draw: function(ctx,ticks,hitX,hitY) {
					var that = this;

					if(this.napalm == null) {
						this.napalm = [];
						for(var i=0;i<game.terrain.heights.length;i++)
							this.napalm[i] = 0;
					}
					var h = function(i) {
						if(i<0) return 1e42;
						if(i>=that.napalm.length) return 1e42;						
						return Math.round(game.terrain.heights[i] + that.napalm[i]);
					}
					
					ctx.fillStyle = 'rgb(200,0,0)';
					var dt = ticks-this.totalTicks;
					for(var a=0; a<2*dt; a++) {
						var xc = Math.round(hitX);
						var d = 0;
						if(h(xc)-h(xc+1)>0) d = -1;
						if(h(xc)-h(xc-1)>0) d = +1;
						while(d!=0) {
							if(h(xc)-h(xc-d)<0) d=0;
							xc -= d;
							if(this.napalm[xc]==0)
								ctx.fillRect(xc,ctx.canvas.height-h(xc),2,2);
						}
						this.napalm[xc]++;
						ctx.fillRect(xc,ctx.canvas.height-h(xc),2,2);
					}
					this.totalTicks = ticks;
					if(this.totalTicks > options.amount) {
						game.tankManager.damage(function(tx,ty) {
							return {
								physical: 0,
								thermal: that.napalm[Math.round(tx)]*2
							}
						});
						return true;
					}
					return false;
					
				}
			},this.x,this.y);

			return true;
		}		
	}
	ProjNapalm.prototype = new Projectile();
	
	var ProjMirv = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.options = options;
		this.flyDur = 0;
		this.tick = function(collisionCtx,dt) {
			this.flyDur += dt;
			var flying = this.__proto__.tick.call(this,collisionCtx,dt);
			if(!flying) return false;
			if(this.flyDur > 1000) {
				for(var i=0; i<this.options.clusters; i++) {
					var speed = Math.sqrt(this.vx*this.vx+this.vy*this.vy);
					var boostX = (this.vy/speed)*50*(i-0.5*this.options.clusters)/this.options.clusters+(Math.random()-0.5)*20;
					var boostY = -(this.vx/speed)*50*(i-0.5*this.options.clusters)/this.options.clusters+(Math.random()-0.5)*20;
					this.game.projectileManager.add(new ProjBomb(this.x,this.y,this.vx+boostX,this.vy+boostY,this.game,this.options));
				}
				this.kill();
				return false;
			}
			return true;
		}
		this.action = function() {
			this.flyDur = 1e42;
			return true;
		}

	}
	ProjMirv.prototype = new ProjBomb();
	
	var ProjNuclear = function(x,y,vx,vy,game,options) {
		this.initialize.apply(this, arguments);
		this.explode = function() {
			this.game.explosionManager.add(this.game.sprites.atom,this.x,this.y,1);

			var bomb = this;
			this.game.tankManager.damage(function(tx, ty) {
				var dx = bomb.x-tx, dy = bomb.y-ty;
				var dist = Math.sqrt(dx*dx+dy*dy);
				return {
					thermal: Math.max(0, options.thermalDamage*(300-dist)/300),
					physical: Math.max(0, options.physicalDamage*(200-dist)/200)
				}
			});

			return true;
		}
	}
	ProjNuclear.prototype = new Projectile();
		

	var Weapon = function(tank, game) {
		this.initialize = function(tank, game) {
			this.tank = tank;
			this.game = game;
			this.name = '';
		}
		this.initialize.apply(this,arguments);
		
		this.fire = function() { return false; }
		this.aimLeft = function() { return false; }
		this.aimRight = function() { return false; }
		this.powerUp = function() { return false; }
		this.powerDown = function() { return false; }
	}
	var MakeProjectileWeapon = function(name,projectile,options) {
		var ProjectileWeapon = function(tank,game) {
			this.initialize.apply(this,arguments);
			this.name = name;

			this.fire = function() {
				var muzzle = this.tank.getMuzzle();
				this.game.projectileManager.add(new projectile(muzzle.x,muzzle.y,muzzle.vx,muzzle.vy,this.game,options));
				return true;
			}
		}
		ProjectileWeapon.prototype = new Weapon();
		return ProjectileWeapon;
	}

	var WepCannon = MakeProjectileWeapon('Kanone', ProjBomb, {size:0.25, damage: 30})
	var WepLightBomb = MakeProjectileWeapon('Leichte Bombe', ProjBomb, {size:0.35, damage: 50})
	var WepHeavyBomb = MakeProjectileWeapon('Schwere Bombe', ProjBomb, {size:0.5, damage: 60})

	var WepDigger = MakeProjectileWeapon('Graber',ProjDigger, {numTunnels: 20, tunnelWidth: 5});
	var WepDirt = MakeProjectileWeapon('Dreck',ProjDirt, {size: 100});
	var WepSuperDirt = MakeProjectileWeapon('Riesen-Dreck',ProjDirt, {size: 200});

	var WepLaser = MakeProjectileWeapon('Laser',ProjLaser, {});

	var WepFrog = MakeProjectileWeapon('Frosch',ProjFrog, {forks:4, size: 0.40, damage: 55});

	var WepNapalm = MakeProjectileWeapon('Napalm',ProjNapalm, {amount:2000});
	var WepHeavyNapalm = MakeProjectileWeapon('Riesen-Napalm',ProjNapalm, {amount:4000});
	
	var Wep6xMirv = MakeProjectileWeapon('6x-Mirv', ProjMirv, {size:0.6, damage: 70, clusters: 6})
	var Wep4xMirv = MakeProjectileWeapon('4x-Mirv', ProjMirv, {size:0.4, damage: 55, clusters: 4})
	var WepClusterBomb = MakeProjectileWeapon('Splitterbombe', ProjMirv, {size:0.15, damage: 20, clusters: 20})

	var WepNuclarBomb = MakeProjectileWeapon('Atom-Bombe', ProjNuclear, {thermalDamage: 300, physicalDamage: 300})
	
	var Armory = function(tank,game) {
		var weapons = [
			{weapon: new WepCannon(tank,game), amount: -1},
			{weapon: new WepLightBomb(tank,game), amount: 5},
			{weapon: new WepHeavyBomb(tank,game), amount: 5},
			{weapon: new WepDigger(tank,game), amount: 5},
			{weapon: new WepDirt(tank,game), amount: 5},
			{weapon: new WepSuperDirt(tank,game), amount: 5},
			{weapon: new WepLaser(tank,game), amount: 5},
			{weapon: new WepFrog(tank,game), amount: 5},
			{weapon: new WepNapalm(tank,game), amount: 5},
			{weapon: new WepHeavyNapalm(tank,game), amount: 5},
			{weapon: new Wep4xMirv(tank,game), amount: 5},
			{weapon: new Wep6xMirv(tank,game), amount: 5},
			{weapon: new WepClusterBomb(tank,game), amount: 5},
			{weapon: new WepNuclarBomb(tank,game), amount: 5},
		];
		var currentWeapon = 0;
		
		this.selectWeapon = function(id) {
			if(weapons[id].amount != 0)
				currentWeapon = id;
			return weapons[currentWeapon];
		}
		this.useWeapon = function() {
			var id = currentWeapon;
			if(weapons[id].amount == 0)
				return false;
			if(weapons[id].amount > 0)
			weapons[id].amount--;
			if(weapons[id].amount == 0)
				currentWeapon = 0;

			return weapons[id].weapon;
		}
		this.listWeapons = function() {
			var list = [];
			for(var i=0; i<weapons.length; i++) {
				if(weapons[i].amount == -1)
					list.push({name: weapons[i].weapon.name, id: i, selected: (i==currentWeapon)});
				if(weapons[i].amount > 0)
					list.push({name: weapons[i].weapon.name+' ('+weapons[i].amount+')', id: i, selected: (i==currentWeapon)});					
			}
			return list;
		}
		
	}
	
	

	var Controller = function() {
		this.inputState = {up: false, down: false, left: false, right: false, fast: false, trigger: false};
		
		this.controlTank = function(tank, game, ticks) {
			if(this.inputState.left) {
				tank.changeAngle((ticks/1000)*(this.inputState.fast?100:20));
				return true;
			}
			if(this.inputState.right) {
				tank.changeAngle(-(ticks/1000)*(this.inputState.fast?100:20));
				return true;
			}
			if(this.inputState.up) {
				tank.changePower((ticks/1000)*(this.inputState.fast?100:20)*5);
				return true;
			}
			if(this.inputState.down) {
				tank.changePower(-(ticks/1000)*(this.inputState.fast?100:20)*5);
				return true;
			}
			if(this.inputState.trigger) {
				this.inputState.trigger = false;
				tank.fire();
			}
			
		}
		this.controlProjectile = function(projectile, game, ticks) {
			if(this.inputState.trigger) {
				projectile.action();
			}
		}
	}
	
	var KeyboardController = function() {
		var controller = this;
		document.documentElement.addEventListener('keydown',function(ev) {
			if(ev.repeat) return;
			if(ev.keyCode == 37) controller.inputState.left = true;
			if(ev.keyCode == 38) controller.inputState.up = true;
			if(ev.keyCode == 39) controller.inputState.right = true;
			if(ev.keyCode == 40) controller.inputState.down = true;

			if(ev.keyCode == 32) controller.inputState.trigger = true;

			if(ev.keyCode == 16) controller.inputState.fast = true;		
			
			ev.stopPropagation(); ev.preventDefault();	
		}, true);
		document.documentElement.addEventListener('keyup',function(ev) {
			if(ev.keyCode == 37) controller.inputState.left = false;
			if(ev.keyCode == 38) controller.inputState.up = false;
			if(ev.keyCode == 39) controller.inputState.right = false;
			if(ev.keyCode == 40) controller.inputState.down = false;

			if(ev.keyCode == 32) controller.inputState.trigger = false;

			if(ev.keyCode == 16) controller.inputState.fast = false;			

			ev.stopPropagation(); ev.preventDefault();	
		}, true);
		var weaponSelection = null;
		this.controlTank = function(tank, game, ticks) {
			if(!weaponSelection) weaponSelection = document.getElementById('tankWeaponSelection')
			tank.armory.selectWeapon(weaponSelection.options[weaponSelection.selectedIndex].value);
			return this.__proto__.controlTank.call(this, tank, game, ticks);
		}
	}
	KeyboardController.prototype = new Controller();
	
	return {

		terrain : {
			heights: [],
			isIndestructible: false,
			
			pseudoFractalLandgen: function(width, maxHeight, roughness) {
				var nextPow2=Math.ceil(Math.log(width)/Math.LN2);
				var nextPow2val=1<<nextPow2;
				var terrain=[];
				terrain[0] = 50+(maxHeight-100)*Math.random();
				terrain[nextPow2val] = 50+(maxHeight-100)*Math.random();
				for(var i=1;i<=nextPow2;i++) {
					var step=1<<(nextPow2-i);
					for(var j=0;j<nextPow2val;j+=step) {
						if(j in terrain) continue;
						do {
							terrain[j] = (terrain[j-step]+terrain[j+step])/2 + ((Math.random()-0.5)*maxHeight)*Math.pow(roughness,0.25*Math.pow(i-1,1.5));
						} while(terrain[j]<0||terrain[j]>maxHeight);
					}
				}
				return terrain.splice(0,width);
			},
			
			solidHillLandgen: function(width, maxHeight,roughness) {
				var terrain = [];
				var a = 0;
				var s = Math.random()*75;
				var v = 0;
				for(var i=0;i<width;i++) {
					v = Math.min(Math.max(v+a*roughness*0.5,-3),3);
					s = Math.max(s+v*roughness,0);
					if (((i%40)==0)||(s<5)||(s>100))
						a = ((Math.random()*3)-1)-a*Math.random()-(((50+s)-(maxHeight*0.5))/maxHeight)*4;
					if(s<5)
						v = v+a;
					if(s>100)
						a = -Math.abs(a);
						
					terrain[i] = Math.min(Math.max(Math.round(25+Math.pow(s,0.8)*4),0),maxHeight);
				}
				
				return terrain;
			},
			
			generate: function(width, maxHeight, options) {
				this.heights = this.pseudoFractalLandgen(width, maxHeight, options['roughness']);
//				this.heights = this.solidHillLandgen(width, maxHeight, options['roughness']);
			},
			
			updateFromImage: function(ctx) {
				if(this.isIndestructible) return;
				var W=ctx.canvas.clientWidth, H=ctx.canvas.clientHeight;
				var pixels = ctx.getImageData(0,0,W,H);
				for(var i=0;i<W;i++) this.heights[i]=0;
				for(var i=0;i<pixels.data.length;i+=4) {
					if(pixels.data[i+0]==Settings.landColor[0] && pixels.data[i+1]==Settings.landColor[1] && pixels.data[i+2]==Settings.landColor[2])
						this.heights[(i/4)%W]++;
				}				
			},
			
			drawToImage: function(ctx) {
				var W=ctx.canvas.clientWidth, H=ctx.canvas.clientHeight;
				var pixels = ctx.getImageData(0,0,W,H);
				for(var i=0;i<pixels.data.length;i+=4) {
					if(this.heights[(i/4)%W] >= (H-(i/4)/W)) {
						pixels.data[i+0]=Settings.landColor[0];
						pixels.data[i+1]=Settings.landColor[1];
						pixels.data[i+2]=Settings.landColor[2];
						pixels.data[i+3]=255;
					} else {
						pixels.data[i+0]=Settings.skyColor[0];
						pixels.data[i+1]=Settings.skyColor[1];
						pixels.data[i+2]=Settings.skyColor[2];
						pixels.data[i+3]=255;
					}
				}
				ctx.putImageData(pixels,0,0);				
			}
		},
		
		explosionManager: {
			animations: [],
			finished: true,
			add: function(sprite,x,y,scale) {
				this.finished = false;
				this.animations.push({sprite: sprite, x: x, y: y, scale: scale, ticks: 0});
			},
			tick: function(ctx,ticks) {
				if(this.finished)
					return true;
				this.finished = true;
				for(var i=0; i<this.animations.length; i++) {
					var anim = this.animations[i];
					if(anim.sprite.draw(ctx,anim.ticks,anim.x,anim.y,anim.scale)) {
						this.animations.splice(i,1);
						i--;
					} else {
						this.finished = false;
					}
					anim.ticks += ticks;
				}
				return this.finished;
			},
		},
		
		tankManager: {
			tanks: [],
			currentTank: -1,
			
			add: function(tank) {
				this.tanks.push(tank);
			},
			
			fall: function(ticks) {
				falling = false;
				for(var i=0; i<this.tanks.length; i++) {
					if(this.tanks[i].fall(ticks))
						falling = true;
				}
				if(falling) return true;
				return false;
			},
			damage: function(callback) {
				for(var i=0; i<this.tanks.length; i++) {
					var tank = this.tanks[i];
					tank.damage(callback(tank.x,tank.y));
				}
			},
			drawAll: function(ctx) {
				for(var i=0; i<this.tanks.length; i++)
					this.tanks[i].draw(ctx);
			},
			
			handleDestructions: function() {
				for(var i=0; i<this.tanks.length; i++) {
					var tank = this.tanks[i];
					if(tank.hitpoints == 0) {
						tank.game.state = "EXPLODING";
						tank.game.explosionManager.add(tank.game.sprites.explosion,tank.x,tank.y,0.15);
						tank.hitpoints = -1;
					}
				}	
			},
			
			nextTank: function() {
				var oldTank = this.currentTank;
				do {
					this.currentTank = (this.currentTank+1) % this.tanks.length;

					if(this.currentTank == oldTank && this.tanks[oldTank].hitpoints <= 0)
						return null; // no tank with hitpoints left.
				} while(this.tanks[this.currentTank].hitpoints <= 0);
				return this.tanks[this.currentTank];
			},
			
			spawnTanks: function(terrain) {
				var dist = (terrain.heights.length-150) / (this.tanks.length-1);
				var positions = [];
				for(var x=0; x<=(terrain.heights.length-150); x+=dist)
					positions.push(Math.round(x)+75);
				console.log(positions)
				for(var i=0; i<this.tanks.length; i++) {
					var x = positions.splice(Math.floor(Math.random()*positions.length),1)[0];
					console.log(x);
					var tank = this.tanks[i];
					tank.hitpoints = tank.maxHitpoints;
					tank.x = x;
					tank.y = terrain.heights[x]+2;
				}
			}
		},
		
		projectileManager: {
			projectiles: [],
			flying: false,
			
			add: function(projectile) {
				this.projectiles.push(projectile);
			},
			
			tick: function(collisonCtx, overlayCtx, ticks, controller) {
				this.flying = false;
				overlayCtx.clearRect(0,0,overlayCtx.canvas.width,overlayCtx.canvas.height)
				for(var i=0; i<this.projectiles.length; i++) {
					if(!this.projectiles[i].landed) {
						if(this.projectiles[i].tick(collisonCtx, ticks))
							this.flying = true;
						else
							this.projectiles[i].landed = true;
					}
					this.projectiles[i].draw(overlayCtx);
					controller.controlProjectile(this.projectiles[i]);
				}
				
				// finished?
				if(this.flying) return false;
				for(var i=0; i<this.projectiles.length; i++) {
					this.projectiles[i].explode();
					this.projectiles.splice(i,1); i--;
				}				
				overlayCtx.clearRect(0,0,overlayCtx.canvas.width,overlayCtx.canvas.height)				
				return true;
			},
		},

		state: "UNINITIALIZED",
		
		sprites: {},
		initialize: function(container,onloadCallback) {
			var game = this;
			
			var spriteLoaded = function() {
				var done = true;
				for(var sprite in game.sprites)
					done &= game.sprites[sprite].initialized;
				game.state = "PREGAME";
				if(done && onloadCallback) onloadCallback();
			}
			this.sprites.explosion = new Sprite('data/explosion.png', 225, 10, 112, 112, spriteLoaded);
			this.sprites.atom = new Sprite('data/atom.png', 290, 30, 160, 250, spriteLoaded);
			
			this.sprites.tankL = new Sprite('data/tank-l.png',13, 1, 0, 0, spriteLoaded);
			this.sprites.tankR = new Sprite('data/tank-r.png',13, 1, 0, 0, spriteLoaded);
			
			this.gui = new FightGUI(container);
		},
		
		controller: new KeyboardController(),
		
		wallManager: new BouncyWallManager(),

		start: function() {
			var ctx = this.gui.gameCtx; var overlayCtx = this.gui.overlayCtx;
		
			this.terrain.generate(ctx.canvas.clientWidth,ctx.canvas.clientHeight-100,{'roughness':0.55});
			this.terrain.drawToImage(ctx);
			this.state = "NEXTTURN";

			this.tankManager.add(new Tank('Player 1',200,{r:255,g:127,b:0},this));
			this.tankManager.add(new Tank('Player 2',200,{r:0,g:255,b:0},this));
			this.tankManager.spawnTanks(this.terrain);
			
			this.tankManager.drawAll(ctx);
	

			// game loop
			var game = this;
			var currentTank = null;
			var lastTicks = -1;
			function doFrame(ticks) {
				if(lastTicks==-1) lastTicks = ticks;
				var dTicks = ticks-lastTicks;
				if(dTicks > 500) {
					// background tab? pause ...
					lastTicks = ticks;
					requestAnimationFrame(doFrame);
					return;
				}
				switch(game.state) {
					case "MOVING":
						if(game.controller.controlTank(currentTank, game, dTicks)) {
							game.terrain.drawToImage(ctx);
							game.tankManager.drawAll(ctx);
							game.gui.display(currentTank);
						}
					break;
					
					case "SHOOTING":
						if(game.projectileManager.tick(ctx,overlayCtx,dTicks,game.controller))
							game.state = "EXPLODING";
							
					break;
					case "EXPLODING":
						if(game.explosionManager.tick(ctx,dTicks)) {
							// all animations complete
							game.terrain.updateFromImage(ctx);
							game.terrain.drawToImage(ctx);
							game.tankManager.drawAll(ctx);
							game.state = "FALLING";
							game.tankManager.handleDestructions();
						}
					break;
					
					case "FALLING":
						if(!game.tankManager.fall(dTicks)) {
							game.state = "NEXTTURN";
							game.tankManager.handleDestructions();
						}
						game.terrain.drawToImage(ctx);
						game.tankManager.drawAll(ctx);
					break;
					
					case "NEXTTURN":
						game.terrain.drawToImage(ctx);
						game.tankManager.drawAll(ctx);
						currentTank = game.tankManager.nextTank();
						game.gui.display(currentTank);

						game.state = "MOVING";
					break;
				}
				lastTicks = ticks;
				requestAnimationFrame(doFrame);
			}
			requestAnimationFrame(doFrame);
		},
		
		fireWeapon: function(weapon, tank) {
			if(weapon.fire())
				this.state = "SHOOTING";
		}

	}
})();

tankwar.initialize(document.getElementById('tankwar'), function() {
	tankwar.start();
});

</script>
</body></html>